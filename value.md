## 问题来源：
&&在定义函数的时候不知道是什么意思

### 1. 左值右值的概念
简单得说，右值是临时的，左值反之。（简单理解）
临时的意思是指用完就会被销毁。左右顾名思义就是可以放在左边或者放在右边。
```
  int x=1;// x为左值，1为右值
  
  int y=x+3;// y为左值，x+3为右值。前面的1已经销毁而x还保留着

  Teacher *tec=new Teacher(); 



```
### 2.左值引用在形参中的使用
所谓左值引用，就是对一个非临时变量进行引用。这样做的好处都是为了能够直接修改原来的对象/参数。以下为用法案例

#### 2.1 要求对传入的形参进行修改，用左值引用
```
  void func1(int& x){x=1};
  void func2(T& t){}{t=Teacher(1,2);}
  int main(){
    int i=100;
    func1(i);
    // 此是的i值变为了1，也就是其在函数内被修改了
    Teacher t(3,4);
    func2(t);
    // 此时的t变成了t(1,2)而非刚传入的t(3,4)
}
```
从这里看出 T t();这样的声明对象的方法返回的t是一个 *引用对象* ，如果要传入new对象，应当这样：
```
  Teacher *tec=new Teacher(3,4);
  func2(*tec);
  
```
从这里看出，new对象是个指针对象，要将指针变为引用需要解引用*
*需要注意的是，通过解引用的方法将指针传给一个要求引用形参的函数，虽然可以直接修改传入的对象本身，但是不能自动释放内存，因此有内存泄漏的风险*
*因此，要么不要这样用（几乎不这样用）要么要及时delete掉传入的对象*

### 3.右值引用在形参中的使用
右值引用的好处集中在将“复制”对象变成“移动”对象。案例如下：

#### 3.1 不需要保存传入的对象的时候，请使用右值引用。

```
  void fuc1(T&& t);
  void main(){
  func1(T(1,2)); 
}
```
粗简得来说就是如此，更深入地说好处在于避免深复制。--->涉及到移动构造函数，移动赋值运算等。


#### 4.左右值引用在返回类型中使用

##### 4.1 返回普通对象

```
  T func1(){ T t(1,2); return t;}
```
这种方法直接返回一个引用对象,其可以返回任何一个符合类型的,且在函数内部可“看到”的对象。
缺陷：实际返回的t并不是原来你定义的tm，而是“偷偷”定义了一个新的T，然后复制过去。很好理解，因为定义在函数内部的对象在离开函数范围后会
自己删除。由此带来的缺陷（1）涉及到拷贝构造函数，如果调用这样的函数多了性能下降 （2）要求有拷贝构造函数，没有的对象返回失败。(各种过程都有可能报错)

##### 4.2 返回(引用)对象的引用（对象默认为引用对象，也就是常说的对象是引用类型）

``` 
  T t(1,2);
  T& func(){
    return t;
}
```
根据写法可以看出这个方法的缺陷和好处都是一样都是，只能返回一个创建函数就定义好的对象/返回的是一个函数前定义好的对象而且不需要拷贝

*补充：返回对象引用也能实现链式调用*

##### 4.3 返回的（引用）对象的指针

```
  T* f func(){
    T* t=new T();
    return t;
}
```
这种方法缺陷明显，返回的是一个定义在函数内部的对象，有内存泄漏的风险。如果返沪的new对象b已经泄漏了，
好处在于返回指针不会触发拷贝，而且在需要返回指针的情况下貌似只有这种方法。
为了降低内存泄漏的风险，需要返回的对象用智能指针返回和创建，如下：
```
#include "memory"
std::unique_ptr<T>  fuc(){
    std::unique_ptr<T> result=std::unique_ptr<T>();
    return result;
}
```

##### 4.4 返回的是右值引用 <------------------------------- 本文档的最终目的
这个右值引用就是返回的是自己的（引用）对象，而不是一个新的（引用）对象（区别于4.1）
```
  T&& func(){
    T t(1,2);
    return std::move(t);
}
```
如果直接return t，触发了拷贝构造函数，性能下降。如果你既不想触发拷贝构造函数，又想要返回一个右值引用(链式调用和前向引用)
前向引用与模板相关，忽略。链式调用即多次调用同一个对象的不同方法：
```
  t.func1().func2();
```

总的来说，这种返回的方法很少用，一般出现在模板的转发。

###### 4.4.1 参数转发
所谓参数转发，就是使用转发参数给不同的模板，还得保留这个参数的左值/右值属性：
```
#include <utility>

// 简单的示例函数，接受一个参数并将其转发给另一个函数
template <typename T>
void forwardFunction(T&& arg) {
    // 此处使用 std::forward 来实现前向引用
    otherFunction(std::forward<T>(arg));
}

// 另一个函数，接受一个参数
void otherFunction(int& x) {
    // 处理左值引用
}

void otherFunction(int&& x) {
    // 处理右值引用
}

int main() {
    int a = 42;
    forwardFunction(a);        // 转发左值
    forwardFunction(123);      // 转发右值
    forwardFunction(std::move(a));  // 转发右值
    return 0;
}

```
